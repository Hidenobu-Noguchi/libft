NAME
	strcat, strncat - concatenate strings

LIBRARY
	Standard CÂ Library (libc, -lc)

SYNOPSIS
	#include <string.h>
	char	*strcat(char *restrict s1, const char *restrict s2);
	char	*strncat(char *restrict s1, const char *restrict s2, size_t n);

ADMONISHMENT
	YOU SHOULD ALMOST CERTAINLY USE strlcat() INSTEAD. See "Security Considerations" below.

DESCRIPTION
	The strcat() and strncat() functions append a copy of the [NULL]-terminated string [s2] to the end of the [NULL]-terminated string [s1],
	then add a terminating '\0'.
	The string [s1] must have sufficient space to hold the result.

	The strncat() function appends not more than [n] characters form [s2], and then adds a terminating '\0'.

	The [s2] and [s1] strings should not overlap, as the behavior is undefined.

RETURN VALUES
	The strcat() and strncat() functions return the pointer [s1].

SECURITY CONSIDERATIONS
	The strcat() function is easily misused in a manner which enables malicious users
	to arbitrarily change a running program's functionality through as buffer overflow attack.  (See the FSA.)

	Avoid using strcat().
	Instead, use strncat() or strlcat() and ensure that no more characters are copied to the destination buffer than it can hold.

	Note that strncat() can also be problematic.
	It may be a security concern for a string to be truncated at all.
	Since the truncated string will not be as long as the original, it may refer to a completely different resource
	and usage of the truncated resource could result in very incorrect behavior.
	Example:

		void	foo (const char *copy)
		{
			char	dest[8] = "";

			# BAD defined
			(void)strcat(dest, copy);

			# BETTER defined
			(void)strncat(dest, copy, (sizeof(dest) - strlen(dest) - 1));

			# BEST defined
			if ((strlen(copy) + 1) > (sizeof(dest) - strlen(dest)))
				err(1, "[dest] would be truncated");
			(void)strncat(dest, copy, (sizeof(dest) - strlen(dest) - 1));
		}

SEE ALSO
	bcopy(3), memccpy(3), memcpy(3), memmove(3), strcpy(3), strlcat(3), strlcpy(3), wcscat(3)
