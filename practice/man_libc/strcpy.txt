NAME
	stpcpy, stpncpy, strcpy, strncpy - copy strings

LIBRARY
	Standard CÂ Library (libc, -lc)

SYNOPSIS
	#include <string.h>
	char	*strcpy(char *dst, const char *src);
	char	*strncpy(char *dst, const char *src, size_t len);

ADMONISHMENT
	YOU SHOULD ALMOST CERTAINLY USE strlcpy() INSTEAD. See "Examples" below.

DESCRIPTION
	The strcpy() function copies the string [src] to [dst] (including the terminating '\0' character.)
	The strncpy() function copy at most [len] characters from [src] into [dst].
	The strncpy() function does not guarantee to [NULL] terminate the string itself.
	If [src] is less than [len] characters long, the remainder of [dst] is filled with '\0' characters.
	Otherwise, [dst] is [not] terminated.

	The [src] and [dst] strings should not overlap, as the behavior is undefined.

RETURN VALUES
	The strcpy() and strncpy() functions return [dst].
	The stpcpy() and stpncpy() functions return a pointer to the terminating '\0' character of [dst].
	If stpncpy() does not terminate [dst] with a [NULL] character,
	it instead returns a pointer to dst[n] (which does not necessarily refer to a valid memory location.)

EXAMPLES
	The following sets chararray[6] = "abc\0\0\0";

		char	chararray[6];

		(void)strncpy(chararray, "abc", sizeof(chararray));


	The following sets chararray[6] = "abcdef";

		char	chararray[6];

		(void)strncpy(chararray, "abcdefg", sizeof(chararray));


	Note that if does not [NULL] terminate [chararray] because the length of the [src] string is greater than or equal to the length argument.

	The following copies as many characters from [input] to [buf] as will fit and [NULL] terminates the result.
	Because strncpy() does not guarantee to [NULL] terminate the string itself, this must be done explicitly.

		char	buf[1024];

		(void)strncpy(buf, input, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = '\0';

	This could be better achieved using strlcpy(3), as shown in the following example:

		(void)strlcpy(buf, input, sizeof(buf));


	Not that because strlcpy(3) is not defined in any standards, it should only be used when portability is not a concern.

SEE ALSO
	bcopy(3), memccpy(3), memcpy(3), memmove(3), strlcpy(3), wcscpy(3)

SECURITY CONSIDERATIONS
	The strcpy() function is easily misused in a manner which enables malicious users
	to arbitrarily change a running program's functionality through a buffer overflow attack.
